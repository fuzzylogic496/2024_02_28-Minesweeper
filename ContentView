import SwiftUI

let GRID_SIZE : Int = 16
let BOMB_COUNT : Int = 35
var amountClicked : Int = 0

struct ResetButton: View {
    @Binding var clicked : [Bool]
    @Binding var squares : [Int]
    @Binding var lost : Bool
    @Binding var won : Bool
    @Binding var flags : [Bool]
    @Binding var flagMode : Bool
    var body: some View {
        Button {
            clicked = Array(repeating: false, count: GRID_SIZE*GRID_SIZE)
            squares = set_board(gridSize: GRID_SIZE, bombCount: BOMB_COUNT)
            lost = false
            won = false
            amountClicked = 0
            flags = Array(repeating: false, count: GRID_SIZE*GRID_SIZE)
            flagMode = false
        } label: {
            Text("Play again")
        }
    }
}

func cascade(squareIndex: Int, gridSize: Int, squares: [Int], clicked: [Bool]) -> [Bool] {
    var newClicked = clicked
    
    let minDeltaX = squareIndex % gridSize == 0 ? 0 : -1
    let maxDeltaX = squareIndex % gridSize == gridSize-1 ? 0 : 1
    if newClicked[squareIndex] {
        amountClicked -= 1
    }
    newClicked[squareIndex] = true
    amountClicked += 1
    
    for deltaY in -1...1 {
        for deltaX in -1...1 {
            if deltaY == 0 && deltaX == 0 {
                continue
            }
            if deltaX > maxDeltaX {
                continue
            }
            if deltaX < minDeltaX {
                continue
            }
            let result = squareIndex + gridSize * deltaY + deltaX
            if result < 0 || result >= gridSize * gridSize {
                continue
            }
            if squares[result] == 0 && !newClicked[result] {
                newClicked = cascade(squareIndex: result, gridSize: gridSize, squares: squares, clicked: newClicked)
            } else {
                if newClicked[result] {
                    amountClicked -= 1
                }
                newClicked[result] = true
                amountClicked += 1
            }
        }
    }
    return newClicked
}

func set_board(gridSize: Int, bombCount: Int) -> [Int] {
    var squares : [Int] = Array(repeating: 0, count: 16*16)
    var bombLocations : [Int] = []
    for _ in 0..<bombCount {
        srand48(Int(Date().timeIntervalSince1970))
        var random_num = Int(arc4random_uniform(UInt32(gridSize*gridSize)))
        while bombLocations.contains(random_num) {
            random_num = Int(arc4random_uniform(UInt32(gridSize*gridSize)))
        }
        squares[random_num] = -1
        bombLocations.append(random_num)
    }
    for squareIndex in 0..<(gridSize*gridSize) {
        if squares[squareIndex] != -1 {
            var adjacentBombs = 0
            
            let minDeltaX = squareIndex % gridSize == 0 ? 0 : -1
            let maxDeltaX = squareIndex % gridSize == gridSize-1 ? 0 : 1
            
            for deltaY in -1...1 {
                for deltaX in -1...1 {
                    if deltaY == 0 && deltaX == 0 {
                        continue
                    }
                    if deltaX > maxDeltaX {
                        continue
                    }
                    if deltaX < minDeltaX {
                        continue
                    }
                    let result = squareIndex + gridSize * deltaY + deltaX
                    if result < 0 || result >= gridSize * gridSize {
                        continue
                    }
                    if squares[result] == -1 {
                        adjacentBombs += 1
                    }
                }
            }
            squares[squareIndex] = adjacentBombs
        }
    }
    return squares
}

struct ContentView: View {
    let light_green = UIColor(red: 0.2, green: 1.0, blue: 0.6, alpha: 1.0)
    let light_brown = UIColor(red: 0.76, green: 0.64, blue: 0.52, alpha: 1.0)
    let light_gray = UIColor(red: 0.47, green: 0.47, blue: 0.47, alpha: 1.0)
    let slightly_darker_gray = UIColor(red: 0.25, green: 0.25, blue: 0.25, alpha: 1.0)
    let numberColors : [UIColor] = [ // each number has its own color
        /*1*/ UIColor.blue, 
        /*2*/ UIColor(red: 0, green: 0.5, blue: 0, alpha: 1.0), 
        /*3*/ UIColor.red, 
        /*4*/ UIColor(red: 0, green: 0, blue: 0.5, alpha: 1.0), 
        /*5*/ UIColor(red: 0.5, green: 0, blue: 0, alpha: 1.0), 
        /*6*/ UIColor(red: 0, green: 0.5, blue: 0.5, alpha: 1.0), 
        /*7*/ UIColor.black, 
        /*8*/ UIColor(red: 0.75, green: 0.75, blue: 0.75, alpha: 1.0)
    ]
    @State private var squares : [Int] = set_board(gridSize: GRID_SIZE, bombCount: BOMB_COUNT)
    @State private var lost : Bool = false
    @State private var clicked : [Bool] = Array(repeating: false, count: GRID_SIZE*GRID_SIZE)
    @State private var won : Bool = false
    @State private var flags : [Bool] = Array(repeating: false, count: GRID_SIZE*GRID_SIZE)
    @State private var flagMode : Bool = false
    var body: some View {
        Button {
            flagMode.toggle()
        } label: {
            ZStack {
                Rectangle()
                    .foregroundColor(Color(flagMode ? slightly_darker_gray : light_gray))
                Image("Flag")
                    .resizable()
                    .scaledToFit()
            }
            .frame(width: 50, height: 50)
        }
        GeometryReader { geometry in
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 16), spacing: 0) {
                ForEach(0..<(GRID_SIZE * GRID_SIZE), id: \.self) { index in
                    Button {
                        if !lost && !won {
                            if !clicked[index] && !flagMode {
                                if squares[index] == -1 {
                                    lost = true
                                } else if squares[index] == 0 {
                                    clicked = cascade(squareIndex: index, gridSize: GRID_SIZE, squares: squares, clicked: clicked)
                                } else {
                                    clicked[index] = true
                                    amountClicked += 1
                                }
                                if GRID_SIZE*GRID_SIZE - amountClicked == BOMB_COUNT && !lost {
                                    won = true
                                }
                            } else if flagMode {
                                flags[index].toggle()
                            }
                        }
                    } label: {
                        if lost && squares[index] == -1 {
                            ZStack {
                                Rectangle()
                                    .foregroundColor(.red)
                                    .frame(width: min(geometry.size.width, geometry.size.height) / CGFloat(GRID_SIZE), height: min(geometry.size.width, geometry.size.height) / CGFloat(GRID_SIZE))
                                Image("Mine")
                                    .resizable()
                                    .scaledToFit()
                            }
                        } else if clicked[index] {
                            ZStack {
                                Rectangle()
                                    .foregroundColor(((index / GRID_SIZE + index % GRID_SIZE) % 2 == 0 ? .brown : Color(light_brown)))
                                    .frame(width: min(geometry.size.width, geometry.size.height) / CGFloat(GRID_SIZE), height: min(geometry.size.width, geometry.size.height) / CGFloat(GRID_SIZE))
                                if squares[index] != 0 {
                                    Text("\(squares[index])")
                                        .bold()
                                        .font(.system(size: min(geometry.size.width, geometry.size.height) / CGFloat(GRID_SIZE) * 0.7)) // Adjust the 0.7 as needed
                                        .foregroundColor(Color(numberColors[squares[index]-1]))
                                }
                            }
                        } else {
                            ZStack {
                                Rectangle()
                                    .foregroundColor(((index / GRID_SIZE + index % GRID_SIZE) % 2 == 0 ? .green : Color(light_green)))
                                    .frame(width: min(geometry.size.width, geometry.size.height) / CGFloat((GRID_SIZE)), height: min(geometry.size.width, geometry.size.height) / CGFloat(GRID_SIZE))
                                if flags[index] {
                                    Image("Flag")
                                        .resizable()
                                        .scaledToFit()
                                }
                            }
                        }
                    }
                }
            }
            .frame(width: min(geometry.size.width, geometry.size.height), height: min(geometry.size.width, geometry.size.height))
        }
        if lost {
            Text("You died")
            ResetButton(clicked: $clicked, squares: $squares, lost: $lost, won: $won, flags: $flags, flagMode: $flagMode)
        }
        if won {
            Text("You won!")
            ResetButton(clicked: $clicked, squares: $squares, lost: $lost, won: $won, flags: $flags, flagMode: $flagMode)
        }
    }
}
